                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    [{"title":"ucore lab2 解题报告","date":"2019-12-07T08:22:06.000Z","url":"/2019/12/07/ucore-lab2/","tags":["OS","ucore"],"categories":["笔记本"],"content":"碎碎念写 lab2 的时候比写 lab1 轻松了不少，虽然这期间电脑耳机接口炸了让我很不爽。接口好了，为什么？Link startlab2 里非 challenge 部分感觉没啥好讲的，比较水，相较而言，从打开电脑到内核启动这段时间是如何形成了段页式的物理内存管理更为重要。下面我就按照启动流程来梳理一遍。编译链接diff 一下 lab1 和 lab2 的 kernel.ld 文件在 lab2 里，入口地址变为了 kern_entry，它为启动内核提供了一些简单的环境。然后修改了加载地址，最主要的差别在 lab2 里，通过和 kern/init/entry.S 配合，建立了临时 pdt 和 pt 。通过这个临时的 pdt，只要开启分页机制，就可以得到一个 va 0 ~ 4M, 0xc0000000 + 0 ~ 4M &lt;-&gt; pa 0 ~ 4M 的临时映射。bootloader在 bootloader 最开始执行的是 bootasm.S 文件。相较于 lab1，这里就只多了一个物理内存探测，并把探测到的物理内存按照 struct e820map 的结构存储在物理地址为 0x8000 的地方。然后加载 gdt 开启保护模式，(注意这个地方物理地址和虚拟地址还是一一对应的关系）调 bootmain.c,bootmain.c 把 kern 的各个段读到了 0x00100000 开始的位置。kernkern 首先开启分页，开启分页过后，必须改变 %eip 的值，因为低地址空间要划分给用户使用，要把最开始建立的映射取消掉，如果不改 %eip 会导致内核跑不起来，改完之后设置一下 esp ebp 然后调 kern_init，（注意到这个时候我们虽然开启了分页，但是只有 0xc0000000 + 0 ~ 4M 是被映射到了物理内存的，我们还需要再 kern_init 中补全页表，并对物理内存进行管理，这也是 lab2 主要在做的事。ucore PracticePractice 1实现 first-fit 连续物理内存分配算法（需要编程）first-fit 要求链表有序，稍微改一下就行了。alloc_pages 的时候原地拆块，然后删除原块即可。fre_pages 的时候生成的新块找一下位置插入就行。你的first fit算法是否有进一步的改进空间要优化就只能考虑更快的找到第一个大小合适的块，可以考虑改一下链表的排序方式，不过这好像就不是 first-fit 了，还是 buddy-system 吧，基本上就是 challenge 的内容。Practice 2实现寻找虚拟地址对应的页表项（需要编程）跟着注释蛮好写的。请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中每个组成部分的含义以及对ucore而言的潜在用处。参见 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？把出现异常的地址放到 cr2 寄存器，然后调 page_fault 处理程序。Practice 3释放某虚地址所在的页并取消对应二级页表项的映射（需要编程）基本上是上面的逆过程数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？页目录项对应一个页表的物理地址，页表项对应某一页到页框，而 Page 全局变量的每一项则对应一个物理页。如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题修改 kern.ld 把 0xC0100000-&gt;0x00100000，KERNBASE 变为 0x00000000，把 pmm.c 里会对低地址进行修改低函数直接暴力注释，不过这样做还是会引起一些问题。Ex Challenge🐦🐦🐦"},{"title":"ucore lab1 解题报告","date":"2019-11-07T08:22:06.000Z","url":"/2019/11/07/ucore-lab1/","tags":["OS","ucore"],"categories":["笔记本"],"content":"这 function.mk 看的我脑壳疼。Makefile 流程整个 Makefile 里调用了两次 add_files_cc ，这两次调用就把编译 kernel 所必须的命令基本就包括完了。kernel这里调用了两个函数，一个函数是 listf_cc ，另一个是 add_files_c。listf_cc：列出某个目录下以 .c .S 结尾的文件add_files_cc： 整个函数封装了一下 add_files，在这里相当于核心函数 do_add_files_to_packet这个函数做了两件事，第一件就是为每个文件生成编译模板，第二件就是把每个 obj file 根据不同的文件类型分别放到 $(__objs_kernel) $(__objs_libs) 里去。因此，Makefile 里的 KOBJS = $(call read_packet,kernel libs) 就包含了生成 kernerl 所需要的所有依赖。bootfile不同于 kern 的流程，在生成 bootfile 的时候，首先编译连接成 obj/bootblock.o，然后 copy 到 obj/bootblock.out，接下来调用sign 判断了输入文件的大小，如果小于 510-byte 就在末尾添加 0x55aa 生成 bin/bootblock，如果大于就直接返回。ucore.img就三行 dd 命令先生成一个 10000 * 512 byte 大小的空文件，然后前 512 字节填充 bootblock，接下来填充 kernelPractice 1Q1操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)kernel编译 kernel 就俩步骤第一行命令-march: 指定架构为 i686，兼容 32 位芯片。-fno-builtin: 只有当 gnu 内建函数以 __builtin_ 开头时才会被编译器识别。-fno-PIC: 不编译成位置独立代码-fno-stack-protector: 不开启栈保护-Wall: 尽可能多的生成警告-ggdn: 生成 gdb 调试信息-m32: 生成 32bit 兼容指令-gstabs: 生成 stabs 格式调试信息-nostdinc: 不在系统目录搜索头文件，只搜索被 -I,-iquote,-isystem 等选项显示指定的目录 -I: 把 \\ 加入到预处理时搜索头文件的列表中-c: 只编译，不链接-o: 指定编译生成的文件的名称将 kern 文件下所有 *.c *.S 文件编译成 *.o 文件。第二行-m elf_i386: 生成 elf_i386 格式的可执行文件 -nostdlib: 不链接标准库-T: 指定链接脚本-o: 指定输出文件名将 *.o 文件链接成 bin/kernelbootblock生成 bootblock 的时候 CFLAG 还多了一个参数 -Os-Os: 为大小优化代码，-Os 允许所有不显著增加编译后文件大小的 -O2 优化，在此基础上会进行一些特定的优化以减小代码大小。这为我们生成 512-byte 的 mbr 提供了便利。同样的参数不再赘述-N: 让 text 段可读可写，不按页对齐数据。-e start: 指定 entry_point 为 start 该符号被定义在 boot/bootasm.S 中-Ttext: 指定 .text 段在运行时加载到内存中的地址，便于重定向ucoreimg见上文Q2一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？大小为 512-byte 且最后两字节分别为 0x55 0xAAPractice 2从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。在初始化位置0x7c00设置实地址断点,测试断点正常。从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。自己找一个bootloader或内核中的代码位置，设置断点并进行测试gdb-gef 可比 tui 高到不知道哪里去了Practice 3Q1为何开启 A20，以及如何开启 A20由于 8086 的地址线只有 20bit，而寻址方式 segment:offset 的方式，最高可以到 0x10ffef，计算一下就是 1087KB 左右，当我们的地址有 21bit 长的时候，第一位就会被丢弃，会产生回绕的现象。但是当 CPU 的地址线大于 20bit 的时候，在实模式下就不会产生回绕，为了保证向下兼容，就需要 A20 Gate 来关闭 A20总线。开启 A20 Gate 需要控制一个叫 8042 键盘控制器的东西，具体如何控制参照 [ucore 附录：关于A20 Gate]Q2如何初始化 GDT表gdt 表被硬编码在了 bootasm.S 里，只需要一行 lgdt gdtdesc 即可。GDT 包含了许多条目，每个条目指明了一段地址的访问权限，粒度等信息。GDT 表必须包含一个空的条目，有些会保存一个指向 GDT 本身的指针。Q3如何使能和进入保护模式只要把 cr0 寄存器的最低位置 1 即可进入保护模式。但是单纯的修改寄存器会产生问题，主要在于保护模式和实模式下寻址时段基址不同，我们要通过 ljmp 来刷新 cpu 的段寄存器。关于分段机制的内容可参考 [ucore 保护模式和分段机制]Practice 4Q1bootloader 如何读取硬盘扇区的?在 bootmain.c 里定义了一个 readsect() 函数，用于读取扇区，代码首先设置状态位，然后调用 insl() 函数读取硬盘一个 sector (512-byte)，这里读取的是逻辑 1 扇区，因为逻辑 0 扇区已经作为了 mbr 。Q2bootloader 是如何加载ELF格式的OS？kernel 是一个 32 位的可执行程序，通过 readelf -h bin/kernel 我们可以大概知道这个 elf header 到底长什么样，注意 32位的 elf 文件的 header 都是固定的 52-byte。Practice 5打印函数栈帧第一个编程题，照着注释做就行了，没啥难度。(3.5) 的注释不是很清楚，可以看下 32 位下栈是怎么布置的就清楚了，大概长这样Practice 6Q1中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？代码挺清楚的，嗯。请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。Q3请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。Ex Challenge 1完善内核态到内核态互转的函数。孩子看了半天（真·半天）终于看懂了。内核态转到用户态代码如上，直接调用切用户态的中断就好。为什么要 sub $0x8, %esp ？从内核态切换到用户态的时候，最开始执行到 call trap 的时候是没有发生特全级的改变的，不会压栈 ss esp，但是在我们执行 iret 的时候，由于将 tf_cs 改为了 USER_CS,发生了特权级的改变，这时候 iret 还会额外弹出 ss esp，所以我们要修栈，这里 esp - 8 就是为了给 ss esp 预留位置用的。为什么要 movl %ebp, %esp ？iret 的时候 pop $0, %esp，我们要修复这个问题。Ex Challenge 2摸了摸了Reference[跟我一起写Makefile][GCC 7.4 Manual]"},{"title":"CSAPP-shell-lab","date":"2019-10-28T12:30:02.000Z","url":"/2019/10/28/CSAPP-shell-lab/","tags":["OS","CSAPP"],"categories":["笔记本"],"content":"记录一下 shell lab 流程mainmain 函数里跑了个死循环，不断读取内容并送到 eval() 处理。evaleval() 函数是 shell 主要的处理函数，处理流程如下代码如下，有两个点需要注意一下。在创建新的线程处理 cmdline 之前，阻塞 chld 防止新线程结束之后，父进程将已经结束的子进程的 pid 加入 job list防止由于 &lt;C-z&gt; &lt;C-c&gt; 而导致子进程未添加到 job list 而成为孤儿进程waitfg这个函数要等待前台函数返回我们用 sigsuspend(sigset_t *) 函数直接挂起父进程，等待子进程结束，然后控制交由父进程。sigsuspend(sigset_t *)可以理解为，挂起当前进程直到出现了 mask 内没有屏蔽的信号。    sigchld_handler这个函数用于处理 sig_chld 信号，也即是说子进程结束时的处理。主要注意子进程退出的三种情况程序正常和由于信号退出，这时候字节把子进程从 job_list 中移除即可程序停止，更新一下状态即可。do_bgfg这是程序处理前后台进程的主要函数，这个函数的处理逻辑也很简单，我们只需要找到进程的 pid，让他继续运行即可，bg/fg 区别只在父进程等待。"},{"title":"CSAPP cache lab","date":"2019-10-22T02:32:07.000Z","url":"/2019/10/22/CSAPP-cache-lab/","tags":["OS","CSAPP"],"categories":["笔记本"],"content":"最近把csapp的cachae lab写完了，记录一下。lab主要有两个部分，一个是 cache simulator，另一个是矩阵转置的缓存优化。cache simulatro核心逻辑还是很简单的，主要是如何实现 LRU 的问题。基本上用时间优先队列就完事了，最后操作的放到最前面。核心代码如下optimize matrix题目给了一个 E=1,b=5,s=5 的缓存，我们要利用缓存优化矩阵转置代码。tagsetblock54552^543232size of cache line: 32 bytestotal size: 32*32 bytesint num: 32*8 = 25632x3232x32 的优化如下，主要注意一个缓存行可以装下八个整数。而 C 语言里的矩阵又是按照行存储的，也就是说，当我们读第一个整数的时候，同一行后面的 7 个整数也会被读入到缓存行里，当下一次访问同一行的时候就会缓存命中。64x648x8refCache Lab 解题报告"},{"title":"简单rop","date":"2019-09-29T06:15:25.000Z","url":"/2019/09/29/简单rop/","tags":["OS","pwn"],"categories":["笔记本"],"content":"最近做了一下 ropemporium 上的题，简单记录一下。0x00 ret2winret2win 有 32 位和 64 位的，两种情况下参数传递的方式不同。ret2win32首先拖到 ida 里看看主要逻辑在 pwnme 里ret 相当于 pop $eippwnme 调用了 fgets ，我们可以利用 fgets 函数进行栈溢出。由于 s 长 0x28 个字节，s 后面就是当前栈帧的 ebp 然后是 ret 时会用到的地址，这样我们就可以让它跳到我们想要的地方，同时这个题啥都没开，payload 就很好糊了。ret2win64这个题解法和上题基本一致，不过有一个区别就是 64 位下，参数通过寄存器传递而不是通过栈传递。payload0x01 splitsplit32同样的栈溢出，我们可以控制返回地址，给了个 usefulfunction注意到调用了 system 函数，我们可以利用 system 函数执行代码，这个时候我们从 .data 段找我们需要的数据payload 如下split6464位，我们这次要把数据通过 rdi 传进 system 函数，所以我们要找到一个能够把数据从栈弄到寄存器。偏移 40.datapayload0x02 callme依次调用 callme_one(), callme_two(), callme_three() 参数 1, 2, 3即可。callme3232 位要注意平衡栈，可以考虑 3 个 pop，或者 add esp, $8callme64这题比较蠢，找个 pop rdi; pop rsi; pop rdx; ret; 的就完事了。"},{"title":"socks5","date":"2019-05-21T14:07:48.000Z","url":"/2019/05/21/socks5/","tags":["network","protocol"],"categories":["笔记本"],"content":"socks5在[rfc1928]有详细的说明。这里只对socks5协议做简单解释，只是抽取了部分rfc中的内容进行翻译。1 使用场景socks5协议的设计初衷是在一个有防火墙的网络中，希望能通过某种方法来提高部分人的网络权限，让这部分人能够安全透明的访问外网。大概是这样的不过国内大多数都是反着用的（笑socks5流程TCP部分协商客户端发送一条请求与socks服务器协商认证方法，请求结构如下。VERNMETHODSMETHODS111 to 255字段解释：VER:socks的版本号，socks为X’05’，长度1字节NMETHODS:认证方法数目，长度1字节METHODS:认证方法，1到255字节服务端从客户端提供的方法中选择一个并返回，返回结构如下。VERMETHOD11可选认证方法如下：X’00’: NO AUTHENTICATION REQUIREDX’01’: GSSAPIX’02’: username/passwordX’03’-X’7F’: IANA assignedX’80’-X’FE’: RESERVED FOR PRIVATE METHODSX’FF’: NO ACCEPTABLE METHODS认证认证部分的说明在[rfc1929]如果客户端选择了username/password认证，那么客户端的请求是长这个样子的VERULENUNAMEPLENPASSWD111to25511to255字段解释：xVER:子协议版本，这里为X’01’ULEN: UNAME字段长度UNAME: 用户名字节数据PLEN: PASSWD字段长度PASSWD: 密码字节数据比较蠢的是，这东西都是明文传输的，这在rfc1929里也有提到服务端返回VERSTATUS11字段解释：VER: 同上STAUTS: X’00’代表认证成功，其他都表示失败请求针对所依赖方法的子协商一旦完成，客户端就发送请求细节。如果协商过的方法包含了针对完整性检查或保密性目的的封装，这些请求必须被包装到所依赖的方法的封装中。SOCKS请求按下述格式进行组织VERCMDRSVATYPDST.ADDRDST.PORT11X’00’1Variable2字段解释：VER: 协议版本号，这里为X’05’CMD: CONNECT: X’01’BIND: X’02’UDP ASSOCIATE: X’03’RSV: X’00’ATYP: 地址类别(ipv4/ipv6/domainname/ipv9)IPV4: X’01’DOMAINNAME: X’03’IPV6: X’04’DST.ADDR: 目的地址DST.PORT: 目的端口号请求类型有下面几种：CONNECT : 0X01， 建立代理连接。比较常见的请求，客服端请求服务器发起链接到目标主机，目标端口的代理。SOCKS 服务器将使用目标主机，目标端口, 客户端的源地址和端口号来评估 CONNECT 请求是否通过。成功之后后续流量都会被转发到目标主机的目标端口。BIND : 0X02，BIND请求被用于要求客户端接受来自服务器连接的协议中。FTP是一个众所周知的例子，它针对命令和状态报告使用主要的“客户端到服务器”的连接，但是用来响应命令（如LS、GET、PUT命令）的数据传输可以使用一条“服务器到客户端”的连接。只有在完成了connnect操作之后才能进行bind操作，bind操作之后，代理服务器会有两次响应, 第一次响应是在创建socket监听完成之后，第二次是在目标机器连接到代理服务器上之后。.建立流程如下：Client随BIND请求，发送其要绑定的地址和端口。Server返回其创建的监听端口的地址和端口。Server创建的监听端口有连接后，返回该连接的源地址和端口。Server端将上述连接中的流量，发送给client的监听端口。UDP ASSOCIATE : 0x03，用于在UDP中继处理中建立一条关联以处理UDP数据报。返回服务器返回格式如下：VERREPRSVATYPBND.ADDRBND.PORT11X’00’1Variable2字段解释（与请求相同的部分不再赘述）：REP:X’00’: succeededX’01’: general SOCKS server failureX’02’: connection not allowed by rulesetX’03’: Network unreachableX’04’: Host unreachableX’05’: Connection refusedX’06’: TTL expiredX’07’: Command not supportedX’08’: Address type not supportedX’09’-X’FF’: 未被分配UDP部分每个UDP数据包必须有如下请求头：RSVFRAGATYPDST.ADDRDST.PORTDATA211Variable2Variable字段解释:RSV: Reserved X’0000’FRAG: Current fragment numberATYP-DST.PORT: 同上DATA: user data参考[1]:Python编写socks5服务器参考[2]:[rfc1929]参考[3]:[rfc1928]"},{"title":"ss partI","date":"2019-05-21T04:43:26.000Z","url":"/2019/05/21/ss_0x00/","tags":["network"],"categories":["笔记本"],"content":"虽然ss已经去世了很久，但它依旧活在我等网友心中。一直想看看ss的实现方式，本次就通过python版本shadowsocks源码来解读ss，本系列文章会分成几个部分，我会尽可能做到详细。首先祭奠原作者@clowwindy代码为@ziggear的备份版本，版本号为2.8.2，地址在这ss的目录结构shadowsocks的目录如下（部分目录已略去）上图所示的目录除掉了测试文件。ss的基本架构ss是基于socks5协议实现的，但和socks5又有所不同。关于socks5协议的简析在这里在ss的目录中有两个main函数，一个在local.py中，另一个在server.py，这两个组成了ss的基本架构在ss当中，作者把proxy服务器拆成了客户端和服务端两个部分，并把中间传输数据进行加密，由此提高数据的安全性。我们首先就从客户端部分代码看起，为了阅读方便，这里略去部分代码。可以看到，sslocal和ssserver的代码差距不大，逻辑是基本一致的，其实我们稍作思考便可以明白，作为sslocal和ssserver可以复用的地方非常的多，差别就在sslocal要处理socks协议而server端不用。c/s端有一个eventloop，并把dns_resolver,tcp_server,udp_server加入了事件循环，处理事件。让我们从这里开始来了解ss究竟是怎么写的。事件处理事件处理的代码都在eventloop.py里，里面主要对不同系统的io复用都封装成了epoll的形式，方便进行统一的调用。事件处理的主要代码如下，（超时处理已略去）：一旦poll中有事件触发，就通过该事件的文件描述符去寻找对应的handler，并通过handler.handle_event处理该事件。handle_event在tcp_relay.pyTCP服务器当在eventloop中的handler是和TCP有关时，会调用tcp_relay.py中的hanlde_event函数，如果该socket是指向自己的，那么说明有新的链接，创建一个新的hanlder并对其进行处理。如果不是，就找到与之对应的hanlder处理UDP服务器UDP对事件的处理更简单，就分成client和server异步DNS简单的错误处理，没出错就直接丢给_handle_data()ref[1]shadowsocks源码分析-协议与结构"}]