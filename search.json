                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            [{"title":"NFA & DFA","date":"2020-03-14T11:28:53.000Z","url":"/2020/03/14/NFA-DFA/","tags":["NFA","DFA","compiler"],"categories":["笔记本"],"content":"看 DFA, NFA 有点头大，记一下，理一下流程。NFANFA 可被 $(Q,\\Sigma, T, q0, F)$ 定义，其中$Q$ 为状态的有限集合$\\Sigma$ 为输入字符集$T$ 为转移函数， 可以表示为 $Q\\times \\Sigma \\to P(Q)$ ，因为每个状态有输入和输出，输入为$\\Sigma$，输出就是下一个状态，在 NFA 中，下一个状态不唯一，所以下个状态表示为 $P(Q)$ ，也就是说 $Q$ 的幂集合$q_0$ 为起始状态在带有 $\\varepsilon$移动 的状态下，NFA 可被扩展为 $NFA-\\varepsilon$ 或者 $NFA-\\lambda$ ，那么此时的 $T$ 可以表示为 $Q\\times (\\Sigma \\cup \\{\\varepsilon\\}) \\to P(Q)$$\\varepsilon$ 移动， 即使说一个状态在没有输入的状况下转化为其他状态，也就是说，当前状态不确定，薛定谔的状态DFADFA 和 NFA 可以互相转化，与 NFA 不同，DFA 在一个输入下只有唯一的一种后继状态，DFA 可以表示为 $Q\\times\\Sigma\\to Q$ 由于 DFA 的性质，还可以写成 $Q\\times\\Sigma^{*}\\to Q$ NFA to DFA即由 $Q\\times\\Sigma\\to P(Q)\\Rightarrow Q\\times\\Sigma\\to Q$，很显然的一个想法是令$Q\\in P(Q)$，也就是说，把 NFA 中由一个输入产生的多个后继状态在不改变 NFA 的情况下组合成一个。这种转换的方法叫幂集构造，由上述公式的变化，易知：如果我们有一个$n$个状态的 NFA，当把它变为 DFA 的时候，我们最多会有 $2^n$ 个状态。如何应用 DFA 来识别 token ?首先我们要把语言划分成不同到成分，即不同到 class，然后如何识别呢？对于每个 class 我们可以定义相应到 DFA ，这可以用语言自带的库实现，比如字符串对比，正则表达式。然后我们只要把不同部分的 DFA 组合到一起形成一个大的 DFA 就可以了。例子在对 sql 进行词法分析对过程中，有个例子就是，当输入为[a-zA-Z]的时候，下一个状态是不确定的，有可能为 Identifier 也可能为 Keyword，即如下 NFA通过魔法，可以转化为如下 DFA实际上，在转换为 DFA 之后，switch 写一下 lexer 就写完了。最近正好在写 sql 的 lexer，看到了几个例子，这里记一下。在 SQL 里，如何快速识别出关键字(KEYWORD)是分析速度最大的影响因素。我看到有两种实现。用 hash 表实现，$O(1)$用 字典🌲 实现， $O(1)$顺序查找，$O(N)$字典树是跑的最快的，因为 hash 表在最差的情况下可能到 $O(N)$ ，当然这也要看 hash 表到实现，但是字典树到最差情况就是 $O(max(len(keyword)))$ ，只要$max(len(keyword))&lt;num_keywords$ 那么字典树就绝对更快。 ping-cap 的 sql parser 就是这么写的。ref:DFA wikiNFA wikipingcap sqlparser"},{"title":"CSAPP-shell-lab","date":"2019-10-28T12:30:02.000Z","url":"/2019/10/28/CSAPP-shell-lab/","tags":["OS","CSAPP"],"categories":["笔记本"],"content":"记录一下 shell lab 流程mainmain 函数里跑了个死循环，不断读取内容并送到 eval() 处理。evaleval() 函数是 shell 主要的处理函数，处理流程如下代码如下，有两个点需要注意一下。在创建新的线程处理 cmdline 之前，阻塞 chld 防止新线程结束之后，父进程将已经结束的子进程的 pid 加入 job list防止由于 &lt;C-z&gt; &lt;C-c&gt; 而导致子进程未添加到 job list 而成为孤儿进程waitfg这个函数要等待前台函数返回我们用 sigsuspend(sigset_t *) 函数直接挂起父进程，等待子进程结束，然后控制交由父进程。sigsuspend(sigset_t *)可以理解为，挂起当前进程直到出现了 mask 内没有屏蔽的信号。    sigchld_handler这个函数用于处理 sig_chld 信号，也即是说子进程结束时的处理。主要注意子进程退出的三种情况程序正常和由于信号退出，这时候字节把子进程从 job_list 中移除即可程序停止，更新一下状态即可。do_bgfg这是程序处理前后台进程的主要函数，这个函数的处理逻辑也很简单，我们只需要找到进程的 pid，让他继续运行即可，bg/fg 区别只在父进程等待。"},{"title":"CSAPP cache lab","date":"2019-10-22T02:32:07.000Z","url":"/2019/10/22/CSAPP-cache-lab/","tags":["OS","CSAPP"],"categories":["笔记本"],"content":"最近把csapp的cachae lab写完了，记录一下。lab主要有两个部分，一个是 cache simulator，另一个是矩阵转置的缓存优化。cache simulatro核心逻辑还是很简单的，主要是如何实现 LRU 的问题。基本上用时间优先队列就完事了，最后操作的放到最前面。核心代码如下optimize matrix题目给了一个 E=1,b=5,s=5 的缓存，我们要利用缓存优化矩阵转置代码。tagsetblock54552^543232size of cache line: 32 bytestotal size: 32*32 bytesint num: 32*8 = 25632x3232x32 的优化如下，主要注意一个缓存行可以装下八个整数。而 C 语言里的矩阵又是按照行存储的，也就是说，当我们读第一个整数的时候，同一行后面的 7 个整数也会被读入到缓存行里，当下一次访问同一行的时候就会缓存命中。64x648x8refCache Lab 解题报告"},{"title":"简单rop","date":"2019-09-29T06:15:25.000Z","url":"/2019/09/29/简单rop/","tags":["OS","pwn"],"categories":["笔记本"],"content":"最近做了一下 ropemporium 上的题，简单记录一下。0x00 ret2winret2win 有 32 位和 64 位的，两种情况下参数传递的方式不同。ret2win32首先拖到 ida 里看看主要逻辑在 pwnme 里ret 相当于 pop $eippwnme 调用了 fgets ，我们可以利用 fgets 函数进行栈溢出。由于 s 长 0x28 个字节，s 后面就是当前栈帧的 ebp 然后是 ret 时会用到的地址，这样我们就可以让它跳到我们想要的地方，同时这个题啥都没开，payload 就很好糊了。ret2win64这个题解法和上题基本一致，不过有一个区别就是 64 位下，参数通过寄存器传递而不是通过栈传递。payload0x01 splitsplit32同样的栈溢出，我们可以控制返回地址，给了个 usefulfunction注意到调用了 system 函数，我们可以利用 system 函数执行代码，这个时候我们从 .data 段找我们需要的数据payload 如下split6464位，我们这次要把数据通过 rdi 传进 system 函数，所以我们要找到一个能够把数据从栈弄到寄存器。偏移 40.datapayload0x02 callme依次调用 callme_one(), callme_two(), callme_three() 参数 1, 2, 3即可。callme3232 位要注意平衡栈，可以考虑 3 个 pop，或者 add esp, $8callme64这题比较蠢，找个 pop rdi; pop rsi; pop rdx; ret; 的就完事了。"},{"title":"socks5","date":"2019-05-21T14:07:48.000Z","url":"/2019/05/21/socks5/","tags":["network","protocol"],"categories":["笔记本"],"content":"socks5在[rfc1928]有详细的说明。这里只对socks5协议做简单解释，只是抽取了部分rfc中的内容进行翻译。1 使用场景socks5协议的设计初衷是在一个有防火墙的网络中，希望能通过某种方法来提高部分人的网络权限，让这部分人能够安全透明的访问外网。大概是这样的不过国内大多数都是反着用的（笑socks5流程TCP部分协商客户端发送一条请求与socks服务器协商认证方法，请求结构如下。VERNMETHODSMETHODS111 to 255字段解释：VER:socks的版本号，socks为X’05’，长度1字节NMETHODS:认证方法数目，长度1字节METHODS:认证方法，1到255字节服务端从客户端提供的方法中选择一个并返回，返回结构如下。VERMETHOD11可选认证方法如下：X’00’: NO AUTHENTICATION REQUIREDX’01’: GSSAPIX’02’: username/passwordX’03’-X’7F’: IANA assignedX’80’-X’FE’: RESERVED FOR PRIVATE METHODSX’FF’: NO ACCEPTABLE METHODS认证认证部分的说明在[rfc1929]如果客户端选择了username/password认证，那么客户端的请求是长这个样子的VERULENUNAMEPLENPASSWD111to25511to255字段解释：xVER:子协议版本，这里为X’01’ULEN: UNAME字段长度UNAME: 用户名字节数据PLEN: PASSWD字段长度PASSWD: 密码字节数据比较蠢的是，这东西都是明文传输的，这在rfc1929里也有提到服务端返回VERSTATUS11字段解释：VER: 同上STAUTS: X’00’代表认证成功，其他都表示失败请求针对所依赖方法的子协商一旦完成，客户端就发送请求细节。如果协商过的方法包含了针对完整性检查或保密性目的的封装，这些请求必须被包装到所依赖的方法的封装中。SOCKS请求按下述格式进行组织VERCMDRSVATYPDST.ADDRDST.PORT11X’00’1Variable2字段解释：VER: 协议版本号，这里为X’05’CMD: CONNECT: X’01’BIND: X’02’UDP ASSOCIATE: X’03’RSV: X’00’ATYP: 地址类别(ipv4/ipv6/domainname/ipv9)IPV4: X’01’DOMAINNAME: X’03’IPV6: X’04’DST.ADDR: 目的地址DST.PORT: 目的端口号请求类型有下面几种：CONNECT : 0X01， 建立代理连接。比较常见的请求，客服端请求服务器发起链接到目标主机，目标端口的代理。SOCKS 服务器将使用目标主机，目标端口, 客户端的源地址和端口号来评估 CONNECT 请求是否通过。成功之后后续流量都会被转发到目标主机的目标端口。BIND : 0X02，BIND请求被用于要求客户端接受来自服务器连接的协议中。FTP是一个众所周知的例子，它针对命令和状态报告使用主要的“客户端到服务器”的连接，但是用来响应命令（如LS、GET、PUT命令）的数据传输可以使用一条“服务器到客户端”的连接。只有在完成了connnect操作之后才能进行bind操作，bind操作之后，代理服务器会有两次响应, 第一次响应是在创建socket监听完成之后，第二次是在目标机器连接到代理服务器上之后。.建立流程如下：Client随BIND请求，发送其要绑定的地址和端口。Server返回其创建的监听端口的地址和端口。Server创建的监听端口有连接后，返回该连接的源地址和端口。Server端将上述连接中的流量，发送给client的监听端口。UDP ASSOCIATE : 0x03，用于在UDP中继处理中建立一条关联以处理UDP数据报。返回服务器返回格式如下：VERREPRSVATYPBND.ADDRBND.PORT11X’00’1Variable2字段解释（与请求相同的部分不再赘述）：REP:X’00’: succeededX’01’: general SOCKS server failureX’02’: connection not allowed by rulesetX’03’: Network unreachableX’04’: Host unreachableX’05’: Connection refusedX’06’: TTL expiredX’07’: Command not supportedX’08’: Address type not supportedX’09’-X’FF’: 未被分配UDP部分每个UDP数据包必须有如下请求头：RSVFRAGATYPDST.ADDRDST.PORTDATA211Variable2Variable字段解释:RSV: Reserved X’0000’FRAG: Current fragment numberATYP-DST.PORT: 同上DATA: user data参考[1]:Python编写socks5服务器参考[2]:[rfc1929]参考[3]:[rfc1928]"},{"title":"ss partI","date":"2019-05-21T04:43:26.000Z","url":"/2019/05/21/ss_0x00/","tags":["network"],"categories":["笔记本"],"content":"虽然ss已经去世了很久，但它依旧活在我等网友心中。一直想看看ss的实现方式，本次就通过python版本shadowsocks源码来解读ss，本系列文章会分成几个部分，我会尽可能做到详细。首先祭奠原作者@clowwindy代码为@ziggear的备份版本，版本号为2.8.2，地址在这ss的目录结构shadowsocks的目录如下（部分目录已略去）上图所示的目录除掉了测试文件。ss的基本架构ss是基于socks5协议实现的，但和socks5又有所不同。关于socks5协议的简析在这里在ss的目录中有两个main函数，一个在local.py中，另一个在server.py，这两个组成了ss的基本架构在ss当中，作者把proxy服务器拆成了客户端和服务端两个部分，并把中间传输数据进行加密，由此提高数据的安全性。我们首先就从客户端部分代码看起，为了阅读方便，这里略去部分代码。可以看到，sslocal和ssserver的代码差距不大，逻辑是基本一致的，其实我们稍作思考便可以明白，作为sslocal和ssserver可以复用的地方非常的多，差别就在sslocal要处理socks协议而server端不用。c/s端有一个eventloop，并把dns_resolver,tcp_server,udp_server加入了事件循环，处理事件。让我们从这里开始来了解ss究竟是怎么写的。事件处理事件处理的代码都在eventloop.py里，里面主要对不同系统的io复用都封装成了epoll的形式，方便进行统一的调用。事件处理的主要代码如下，（超时处理已略去）：一旦poll中有事件触发，就通过该事件的文件描述符去寻找对应的handler，并通过handler.handle_event处理该事件。handle_event在tcp_relay.pyTCP服务器当在eventloop中的handler是和TCP有关时，会调用tcp_relay.py中的hanlde_event函数，如果该socket是指向自己的，那么说明有新的链接，创建一个新的hanlder并对其进行处理。如果不是，就找到与之对应的hanlder处理UDP服务器UDP对事件的处理更简单，就分成client和server异步DNS简单的错误处理，没出错就直接丢给_handle_data()ref[1]shadowsocks源码分析-协议与结构"}]